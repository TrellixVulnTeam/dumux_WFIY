<!-- Important: This file has been automatically generated by generate_example_docs.py. Do not edit this file directly! -->


| [:arrow_left: Back to the main documentation](../README.md) | [:arrow_right: Continue with part 2](main.md) |
|---|---:|

# Part 1: Simulation setup

The code documentation is structured as follows:

[[_TOC_]]


## Compile-time settings (`properties.hh`)
This file defines the `TypeTag` used for the simulation in this example, for
which we specialize a number of compile-time `properties`.

<details open>
<summary><b>Click to hide/show the file documentation</b> (or inspect the [source code](../properties.hh))</summary>

### Includes
<details><summary> Click to show includes</summary>

```cpp

#include <dune/grid/yaspgrid.hh> // for `Dune::YaspGrid`
```

The `OneP` type tag specializes most of the `properties` required for single-
phase flow simulations in DuMu<sup>x</sup>. We will use this in the following to inherit the
respective properties, and subsequently specialize those properties for our
type tag, which we want to modify or for which no meaningful default can be set.

```cpp
#include <dumux/porenetworkflow/1p/model.hh>// for `TTag::PNMOneP`
```

The local residual for incompressible flow is included.
The one-phase flow model (included above) uses a default implementation of the
local residual for single-phase flow. However, in this example we are using an
incompressible fluid phase. Therefore, we are including the specialized local
residual which contains functionality to analytically compute the entries of
the Jacobian matrix. We will use this in the main file.

```cpp
#include <dumux/porousmediumflow/1p/incompressiblelocalresidual.hh>
```

We will use a single liquid phase consisting of a component with constant fluid properties.

```cpp
#include <dumux/material/components/constant.hh>
#include <dumux/material/fluidsystems/1pliquid.hh>
```

The classes that define the problem and parameters used in this simulation

```cpp
#include "problem.hh"
#include "spatialparams.hh"
```

</details>

### `TypeTag` definition
A `TypeTag` for our simulation is defined, which inherits properties from the
single-phase flow model and the box scheme.

```cpp
namespace Dumux::Properties {
namespace TTag {
struct PNMUpscaling { using InheritsFrom = std::tuple<PNMOneP>; };
}
```

### Property specializations

In the following piece of code, mandatory `properties` for which no meaningful
default can be set, are specialized for our type tag `PNMUpscaling`.

```cpp
// We use a structured 1D grid with an offset. This allows us to define the
// computational domain to be between the radii $`r_1`$ and $`r_2`$ as illustrated
// in the beginning of the documentation of this example
template<class TypeTag>
struct Grid<TypeTag, TTag::PNMUpscaling>
{ using type = Dune::FoamGrid<1, 3>; };

// The problem class specifying initial and boundary conditions:
template<class TypeTag>
struct Problem<TypeTag, TTag::PNMUpscaling>
{ using type = UpscalingProblem<TypeTag>; };

//! The spatial parameters to be employed.
//! Use PNMOnePSpatialParams by default.
template<class TypeTag>
struct SpatialParams<TypeTag, TTag::PNMUpscaling>
{
private:
    using GridGeometry = GetPropType<TypeTag, Properties::GridGeometry>;
    using Scalar = GetPropType<TypeTag, Properties::Scalar>;
public:
    using type = UpscalingSpatialParams<GridGeometry, Scalar>;
};

//! The advection type
template<class TypeTag>
struct AdvectionType<TypeTag, TTag::PNMUpscaling>
{
private:
    using Scalar = GetPropType<TypeTag, Properties::Scalar>;
    using TransmissibilityLaw = TransmissibilityPatzekSilin<Scalar, true/*considerPoreBodyResistance*/>;
public:
    using type = Dumux::PoreNetworkCreepingFlow<Scalar, TransmissibilityLaw>;
};

// We use a single liquid phase consisting of a component with constant fluid properties.
template<class TypeTag>
struct FluidSystem<TypeTag, TTag::PNMUpscaling>
{
private:
    using Scalar = GetPropType<TypeTag, Properties::Scalar>;
public:
    using type = FluidSystems::OnePLiquid<Scalar, Components::Constant<1, Scalar> >;
};
```

Moreover, here we use a local residual specialized for incompressible flow
that contains functionality related to analytic differentiation.

```cpp
template<class TypeTag>
struct LocalResidual<TypeTag, TTag::PNMUpscaling>
{ using type = OnePIncompressibleLocalResidual<TypeTag>; };

} // end namespace Dumux::Properties
```


</details>



## The problem class (`problem.hh`)
This file contains the __problem class__ which defines the initial and boundary
conditions for the single-phase flow simulation.

<details open>
<summary><b>Click to hide/show the file documentation</b> (or inspect the [source code](../problem.hh))</summary>

### Includes

```cpp
#include <dumux/common/boundarytypes.hh> // for `BoundaryTypes`
#include <dumux/common/properties.hh> // for `GetPropType`
#include <dumux/common/parameters.hh> // for `getParam`
#include <dumux/porousmediumflow/problem.hh>  // for `PorousMediumFlowProblem`
```

### The problem class
We enter the problem class where all necessary boundary conditions and initial conditions are set for our simulation.
As this is a porous medium flow problem, we inherit from the base class `PorousMediumFlowProblem`.

```cpp
namespace Dumux {

template<class TypeTag>
class UpscalingProblem : public PorousMediumFlowProblem<TypeTag>
{
    using ParentType = PorousMediumFlowProblem<TypeTag>;
    using GridGeometry = GetPropType<TypeTag, Properties::GridGeometry>;
    using FVElementGeometry = typename GetPropType<TypeTag, Properties::GridGeometry>::LocalView;
    using SubControlVolume = typename FVElementGeometry::SubControlVolume;
    using Scalar = GetPropType<TypeTag, Properties::Scalar>;
    using PrimaryVariables = GetPropType<TypeTag, Properties::PrimaryVariables>;
    using Indices = typename GetPropType<TypeTag, Properties::ModelTraits>::Indices;
    using BoundaryTypes = Dumux::BoundaryTypes<PrimaryVariables::size()>;
    using Element = typename GridGeometry::GridView::template Codim<0>::Entity;
    using GlobalPosition = typename Element::Geometry::GlobalCoordinate;
    static constexpr int dimworld = GridGeometry::GridView::dimensionworld;

public:
```

In the constructor, we obtain a number of parameters, related to fluid
properties and boundary conditions, from the input file.

```cpp
    template<class SpatialParams>
    UpscalingProblem(std::shared_ptr<const GridGeometry> gridGeometry, std::shared_ptr<SpatialParams> spatialParams)
    : ParentType(gridGeometry, spatialParams)
    {
        // the applied pressure gradient
        pressureGradient_ = getParam<Scalar>("Problem.PressureGradient");

        for (int i = 0; i < dimworld; ++i)
            lenght_[i] = this->gridGeometry().bBoxMax()[i] - this->gridGeometry().bBoxMin()[i];

        eps_ = getParam<Scalar>("Problem.Epsilon", 1e-7);
        useLabels_ = getParam<bool>("Problem.UseLabels", true);
    }
```

We need to specify a constant temperature for our isothermal problem.
Fluid properties that depend on temperature will be calculated with this value.

```cpp
    Scalar temperature() const
    { return 283.15; }
```

#### Specify the types of boundary conditions
This function is used to define the type of boundary conditions used depending on the location.
Two types of boundary  conditions can be specified: Dirichlet or Neumann boundary condition.
On a Dirichlet boundary, the values of the primary variables need to be fixed. On a Neumann
boundary condition, values for derivatives need to be fixed. Here, we use Dirichlet boundary
conditions on all boundaries.

```cpp
    BoundaryTypes boundaryTypes(const Element &element, const SubControlVolume& scv) const
    {
        BoundaryTypes bcTypes;

        if (isInletPore_(scv)|| isOutletPore_(scv))
        {
            bcTypes.setAllDirichlet();
        }
        else // neuman for the remaining boundaries
            bcTypes.setAllNeumann();

        return bcTypes;
    }

    /*!
     * \brief Evaluate the boundary conditions for a dirichlet
     *        control volume.
     *
     * \param values The dirichlet values for the primary variables
     * \param vertex The vertex (pore body) for which the condition is evaluated
     *
     */
     PrimaryVariables dirichlet(const Element &element,
                                const SubControlVolume &scv) const
     {
        PrimaryVariables values(0.0);

        if (isInletPore_(scv))
            values[Indices::pressureIdx] = pressureGradient_ * lenght_[direction_];
        else
            values[Indices::pressureIdx] = 0.0;

        return values;
    }

    /*!
     * \brief Sets the current direction in which the pressure gradient is applied
     * \param directionIdx The index of the direction (0:x, 1:y, 2:z)
     */
    void setDirection(int directionIdx)
    { direction_ = directionIdx; }


private:

    bool isInletPore_(const SubControlVolume& scv) const
    {
        const auto poreLabel = this->gridGeometry().poreLabel(scv.dofIndex());

        if (poreLabel < 0)
            return false;

        if (useLabels_)
            return poreLabel == 1 + 2*direction_;
        else
            return scv.dofPosition()[direction_] < this->gridGeometry().bBoxMin()[direction_] + eps_;
    }

    bool isOutletPore_(const SubControlVolume& scv) const
    {
        const auto poreLabel = this->gridGeometry().poreLabel(scv.dofIndex());

        if (poreLabel < 0)
            return false;

        if (useLabels_)
            return poreLabel == 2 + 2*direction_;
        else
            return scv.dofPosition()[direction_] > this->gridGeometry().bBoxMax()[direction_] - eps_;
    }
```

private data members

```cpp
    Scalar eps_;
    Scalar pressureGradient_;
    int direction_;
    std::array<Scalar, dimworld> lenght_;
    bool useLabels_;
};

} // end namespace Dumux
```

[[/codeblock]]

</details>


| [:arrow_left: Back to the main documentation](../README.md) | [:arrow_right: Continue with part 2](main.md) |
|---|---:|

